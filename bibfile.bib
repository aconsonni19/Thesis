@misc{mitre_glossary,
  author = {MITRE},
  title = {Common Weakness Enumeration Glossary},
  year = {2024},
  note = {Accesso effettuato il 26 settembre 2025},
  url = {https://cwe.mitre.org/documents/glossary/},
}

@article{static_analysis_introduction,
author = {Thomson, Patrick},
title = {Static analysis},
year = {2021},
issue_date = {January 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {65},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/3486592},
doi = {10.1145/3486592},
abstract = {The fundamental challenge of software engineering is one of complexity.},
journal = {Commun. ACM},
month = dec,
pages = {50–54},
numpages = {5}
}

@InProceedings{Review_of_static_analysis,
author="Xu, Yixiao
and Zhang, Man
and Wang, Xiaopeng
and Chen, Junhan
and Liang, Rufeng
and Zhen, Yong
and Zhen, Chencong",
editor="Li, Shaofan",
title="A Review of Code Vulnerability Detection Techniques Based on Static Analysis",
booktitle="Computational and Experimental Simulations in Engineering",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="251--272",
abstract="Blockchain-based applications, such as web3.0, play an increasingly important role in the future internet, but security issues pose a significant threat to their development. Static analysis techniques can help mitigate software vulnerabilities, including those in smart contracts, by analyzing the source code of blockchain-based applications without executing it to identify potential security issues. This paper provides a comprehensive overview of the relationship between blockchain-based applications and static analysis-based code vulnerability detection techniques with a focus on smart contracts. First, it introduces the background of both blockchain and static analysis techniques. Then, it discusses the theoretical foundation of static analysis and the different analysis methods based on intermediate representations of code. It also offers a review of the key techniques and achievements in the fields of traditional static analysis and learning-based analysis, highlighting the particular challenges of applying them to smart contracts. Finally, the paper discusses the challenges in code vulnerability detection based on static analysis and provides potential future research directions. Our literature review aims to provide software developers and researchers with a comprehensive perspective on the relationship among blockchain-based applications, smart contracts and static analysis-based code vulnerability detection techniques, which can help enhance the security of these applications and promote their practical application in the future internet.",
isbn="978-3-031-44947-5"
}

@INPROCEEDINGS{Bintaint,
  author={Feng, Zenan and Wang, Zhenyu and Dong, Weiyu and Chang, Rui},
  booktitle={2018 International Conference on Cloud Computing, Big Data and Blockchain (ICCBB)}, 
  title={Bintaint: A Static Taint Analysis Method for Binary Vulnerability Mining}, 
  year={2018},
  volume={},
  number={},
  pages={1-8},
  keywords={Decoding;Data mining;Explosions;Tools;Pollution;Software;Flow graphs;taint analysis;vulnerability mining;path explosion},
  doi={10.1109/ICCBB.2018.8756383}}

@inproceedings{CodeSurfer,
author = {Balakrishnan, Gogul and Gruian, Radu and Reps, Thomas and Teitelbaum, Tim},
title = {CodeSurfer/x86—A platform for analyzing x86 executables},
year = {2005},
isbn = {3540254110},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-540-31985-6_19},
doi = {10.1007/978-3-540-31985-6_19},
abstract = {CodeSurfer/x86 is a prototype system for analyzing x86 executables. It uses a static-analysis algorithm called value-set analysis (VSA) to recover intermediate representations that are similar to those that a compiler creates for a program written in a high-level language. A major challenge in building an analysis tool for executables is in providing useful information about operations involving memory. This is difficult when symbol-table and debugging information is absent or untrusted. CodeSurfer/x86 overcomes these challenges to provide an analyst with a powerful and flexible platform for investigating the properties and behaviors of potentially malicious code (such as COTS components, plugins, mobile code, worms, Trojans, and virus-infected code) using (i) CodeSurfer/x86's GUI, (ii) CodeSurfer/x86's scripting language, which provides access to all of the intermediate representations that CodeSurfer/x86 builds for the executable, and (iii) GrammaTech's Path Inspector, which is a tool that uses a sophisticated pattern-matching engine to answer questions about the flow of execution in a program.},
booktitle = {Proceedings of the 14th International Conference on Compiler Construction},
pages = {250–254},
numpages = {5},
location = {Edinburgh, UK},
series = {CC'05}
}
@INPROCEEDINGS{Survey_of_Binary_Code_Security_Analysis,
  author={Qingyang, Wu and Quanrui, Huo and Yuqiao, Ning and Chenya, Bian and Zhen, Guo and Shiwen, Shen},
  booktitle={2023 6th International Conference on Data Science and Information Technology (DSIT)}, 
  title={A Survey of Binary Code Security Analysis}, 
  year={2023},
  volume={},
  number={},
  pages={42-49},
  keywords={Source coding;Instruments;Binary codes;Static analysis;Software;Performance analysis;Security;program security;binary analysis techniques;static binary analysis;dynamic binary analysis;hybrid dynamic and static analysis},
  doi={10.1109/DSIT60026.2023.00015}
}

@inbook{QuickBCC,
author = {Jang, Hajin and Yang, Kyeongseok and Lee, Geonwoo and Na, Yoonjong and Seideman, Jeremy and Luo, Shoufu and Lee, Heejo and Dietrich, Sven},
year = {2021},
month = {06},
pages = {66-82},
title = {QuickBCC: Quick and Scalable Binary Vulnerable Code Clone Detection},
isbn = {978-3-030-78119-4},
doi = {10.1007/978-3-030-78120-0_5}
}

@INPROCEEDINGS{VulneraBin,
  author={Tai, Zeming and Washizaki, Hironori and Fukazawa, Yoshiaki and Fujimatsu, Yurie and Kanai, Jun},
  booktitle={2020 IEEE 44th Annual Computers, Software, and Applications Conference (COMPSAC)}, 
  title={Binary Similarity Analysis for Vulnerability Detection}, 
  year={2020},
  volume={},
  number={},
  pages={1121-1122},
  keywords={Measurement;Optimization;Computer science;Registers;Software;Static analysis;Binary codes;binary analysis;static analysis;binary code search;binary similarity},
  doi={10.1109/COMPSAC48688.2020.0-110}}

@inproceedings{Statistical_similarities_in_binaries,
author = {David, Yaniv and Partush, Nimrod and Yahav, Eran},
title = {Statistical similarity of binaries},
year = {2016},
isbn = {9781450342612},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2908080.2908126},
doi = {10.1145/2908080.2908126},
abstract = {We address the problem of finding similar procedures in stripped binaries. We present a new statistical approach for measuring the similarity between two procedures. Our notion of similarity allows us to find similar code even when it has been compiled using different compilers, or has been modified. The main idea is to use similarity by composition: decompose the code into smaller comparable fragments, define semantic similarity between fragments, and use statistical reasoning to lift fragment similarity into similarity between procedures. We have implemented our approach in a tool called Esh, and applied it to find various prominent vulnerabilities across compilers and versions, including Heartbleed, Shellshock and Venom. We show that Esh produces high accuracy results, with few to no false positives -- a crucial factor in the scenario of vulnerability search in stripped binaries.},
booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {266–280},
numpages = {15},
keywords = {partial equivalence, static binary analysis, statistical similarity, verification-aided similarity},
location = {Santa Barbara, CA, USA},
series = {PLDI '16}
}

@TechReport{DBA_DBI,
  author =	 {Nethercote, Nicholas},
  title = 	 {{Dynamic binary analysis and instrumentation}},
  year = 	 2004,
  month = 	 nov,
  url = 	 {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-606.pdf},
  institution =  {University of Cambridge, Computer Laboratory},
  doi = 	 {10.48456/tr-606},
  number = 	 {UCAM-CL-TR-606}
}

@article{Synergy_Duality,
author = {Ernst, Michael},
year = {2003},
month = {05},
pages = {},
title = {Static and Dynamic Analysis: Synergy and Duality}
}

@ARTICLE{Fuzzing_soa,
  author={Liang, Hongliang and Pei, Xiaoxiao and Jia, Xiaodong and Shen, Wuwei and Zhang, Jian},
  journal={IEEE Transactions on Reliability}, 
  title={Fuzzing: State of the Art}, 
  year={2018},
  volume={67},
  number={3},
  pages={1199-1218},
  keywords={Fuzzing;Computer bugs;Software testing;Security;Fuzzing;reliability;security;software testing;survey},
  doi={10.1109/TR.2018.2834476}}

@article{Fuzzing_survey,
author = {Li, Jun and Zhao, Bodong and Zhang, Chao},
year = {2018},
month = {12},
pages = {},
title = {Fuzzing: a survey},
volume = {1},
journal = {Cybersecurity},
doi = {10.1186/s42400-018-0002-y}
}
@ARTICLE{ML_Survey,
  author={Xue, Hongfa and Sun, Shaowen and Venkataramani, Guru and Lan, Tian},
  journal={IEEE Access}, 
  title={Machine Learning-Based Analysis of Program Binaries: A Comprehensive Study}, 
  year={2019},
  volume={7},
  number={},
  pages={65889-65912},
  keywords={Feature extraction;Binary codes;Machine learning;Training;Malware;Taxonomy;Machine learning;program binary analysis;taxonomy},
  doi={10.1109/ACCESS.2019.2917668}
}

@inproceedings{ML1,
author = {Aumpansub, Amy and Huang, Zhen},
title = {Learning-based Vulnerability Detection in Binary Code},
year = {2022},
isbn = {9781450395700},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3529836.3529926},
doi = {10.1145/3529836.3529926},
abstract = {Cyberattacks typically exploit software vulnerabilities to compromise computers and smart devices. To address vulnerabilities, many approaches have been developed to detect vulnerabilities using deep learning. However, most learning-based approaches detect vulnerabilities in source code instead of binary code. In this paper, we present our approach on detecting vulnerabilities in binary code. Our approach uses binary code compiled from the SARD dataset to build deep learning models to detect vulnerabilities. It extracts features on the syntax information of the assembly instructions in binary code, and trains two deep learning models on the features for vulnerability detection. From our evaluation, we find that the BLSTM model has the best performance, which achieves an accuracy rate of 81\% in detecting vulnerabilities. Particularly the F1-score, recall, and specificity of the BLSTM model are 75\%, 95\% and 75\% respectively. This indicates that the model is balanced in detecting both vulnerable code and non-vulnerable code.},
booktitle = {Proceedings of the 2022 14th International Conference on Machine Learning and Computing},
pages = {266–271},
numpages = {6},
keywords = {deep learning, machine learning, neural network, software vulnerability, vulnerability detection},
location = {Guangzhou, China},
series = {ICMLC '22}
}

@ARTICLE{DeepVL,
  author={Li, Runhao and Zhang, Chen and Feng, Chao and Zhang, Xing and Tang, Chaojing},
  journal={IEEE Access}, 
  title={Locating Vulnerability in Binaries Using Deep Neural Networks}, 
  year={2019},
  volume={7},
  number={},
  pages={134660-134676},
  keywords={Neural networks;Software;Computer crashes;Tools;Manuals;Deep learning;Debugging;Binary program crash;deep learning;execution trace;fault localization;neural networks;software security},
  doi={10.1109/ACCESS.2019.2942043}
}

@article{ML2,
  author    = {Pengzhi Xu and Zetian Mai and Yuhao Lin and Zhen Guo and Victor S. Sheng},
  title     = {A Survey on Binary Code Vulnerability Mining Technology},
  journal   = {Journal of Information Hiding and Privacy Protection},
  volume    = {3},
  number    = {4},
  pages     = {165--179},
  year      = {2021},
  url       = {http://www.techscience.com/jihpp/v3n4/47056},
  issn      = {2637-4226}
}

@article{Disassembly,
author = {Marius, Popa},
year = {2012},
month = {12},
pages = {},
title = {Binary Code Disassembly for Reverse Engineering},
volume = {4},
journal = {JOURNAL OF MOBILE, EMBEDDED AND DISTRIBUTED SYSTEMS - JMEDS}
}

@INPROCEEDINGS{Disassembly2,
  author={Schwarz, B. and Debray, S. and Andrews, G.},
  booktitle={Ninth Working Conference on Reverse Engineering, 2002. Proceedings.}, 
  title={Disassembly of executable code revisited}, 
  year={2002},
  volume={},
  number={},
  pages={45-54},
  keywords={Reverse engineering;Software systems;Assembly;Computer science;Libraries;Joining processes;Information analysis},
  doi={10.1109/WCRE.2002.1173063}
}

@article{Cifuentes1995DecompilationOB,
  title={Decompilation of binary programs},
  author={Cristina Garcia Cifuentes and Kevin John Gough},
  journal={Software: Practice and Experience},
  year={1995},
  volume={25},
  url={https://api.semanticscholar.org/CorpusID:8229401}
}

@INPROCEEDINGS{DDG,
  author={Xinyu Wang and Jianling Sun and Xiaohu Yang and Zhijun He and Maddineni, S.},
  booktitle={2004 IEEE International Conference on Systems, Man and Cybernetics (IEEE Cat. No.04CH37583)}, 
  title={Automatically identifying domain variables based on data dependence graph}, 
  year={2004},
  volume={4},
  number={},
  pages={3389-3394 vol.4},
  keywords={Data mining;Documentation;Sun;Helium;Educational institutions;Availability;Application software;Data engineering;Systems engineering and theory;Control systems},
  doi={10.1109/ICSMC.2004.1400866}}

@article{Sclicing,
author = {Xu, Baowen and Qian, Ju and Zhang, Xiaofang and Wu, Zhongqiang and Chen, Lin},
title = {A brief survey of program slicing},
year = {2005},
issue_date = {March 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {30},
number = {2},
issn = {0163-5948},
url = {https://doi.org/10.1145/1050849.1050865},
doi = {10.1145/1050849.1050865},
abstract = {Program slicing is a technique to extract program parts with respect to some special computation. Since Weiser first proposed the notion of slicing in 1979, hundreds of papers have been presented in this area. Tens of variants of slicing have been studied, as well as algorithms to compute them. Different notions of slicing have different properties and different applications. These notions vary from Weiser's syntax-preserving static slicing to amorphous slicing which is not syntax-preserving, and the algorithms can be based on dataflow equations, information-flow relations or dependence graphs.Slicing was first-developed to facilitate debugging, but it is then found helpful in many aspects of the software development life cycle, including program debugging, software testing, software measurement, program comprehension, software maintenance, program parallelization and so on.Over the last two decades, several surveys on program slicing have been presented. However, most of them only reviewed parts of researches on program slicing or have now been out of date. People who are interested in program slicing need more information about the up to date researches. Our survey fills this gap. In this paper, we briefly review most of existing slicing techniques including static slicing, dynamic slicing and the latest slicing techniques. We also discuss the contribution of each work and compare the major difference between them. Researches on slicing are classified by the research hot spots such that people can be kept informed of the overall program slicing researches.},
journal = {SIGSOFT Softw. Eng. Notes},
month = mar,
pages = {1–36},
numpages = {36},
keywords = {program slicing, program analysis, pointer analysis, dependence analysis, debugging}
}

@inproceedings{weiser1981program,
  author    = {Mark Weiser},
  title     = {Program Slicing},
  booktitle = {Proceedings of the 5th International Conference on Software Engineering (ICSE)},
  year      = {1981},
  pages     = {439--449},
  publisher = {IEEE Press}
}

@article{korel1988dynamic,
  author  = {Bogdan Korel and Janusz W. Laski},
  title   = {Dynamic Program Slicing},
  journal = {Information Processing Letters},
  volume  = {29},
  number  = {3},
  pages   = {155--163},
  year    = {1988},
  publisher = {Elsevier}
}

@article{Symbolic_exc_1,
author = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
title = {A Survey of Symbolic Execution Techniques},
year = {2018},
issue_date = {May 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/3182657},
doi = {10.1145/3182657},
abstract = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
journal = {ACM Comput. Surv.},
month = may,
articleno = {50},
numpages = {39},
keywords = {static analysis, software testing, concolic execution, Symbolic execution}
}

@inproceedings{Cifuentes1994ReverseCT,
  title={Reverse compilation techniques},
  author={Cristina Garcia Cifuentes},
  year={1994},
  url={https://api.semanticscholar.org/CorpusID:110021381}
}

@misc{Capstone_docs,
  author = {Capstone},
  title = {Capstone documentation},
  year = {2014},
  note = {Accesso effettuato il 13 ottobre 2025},
  url = {https://www.capstone-engine.org/documentation.html},
}

@book{eagle2020ghidra,
  author    = {Chris Eagle and Kara Nance},
  title     = {The Ghidra Book: The Definitive Guide},
  publisher = {No Starch Press},
  year      = {2020},
  isbn      = {978‑1718501027},
  pages     = {608}
}

@INPROCEEDINGS{angr_introductory_paper,
  author={Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and Stephens, Nick and Polino, Mario and Dutcher, Andrew and Grosen, John and Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle={2016 IEEE Symposium on Security and Privacy (SP)}, 
  title={SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis}, 
  year={2016},
  volume={},
  number={},
  pages={138-157},
  keywords={Computer bugs;Semantics;Security;Binary codes;Engines;Operating systems;attacks and defenses;security architectures;system security},
  doi={10.1109/SP.2016.17}
}

@misc{angr_architecture,
  author = {Emilio Coppa},
  title = {Symbolic Execution},
  note = {Accesso effettuato il 14 ottobre 2025},
  url = {https://www.slideshare.net/slideshow/symbolic-execution/124783109},
}

@INPROCEEDINGS{VulnDetect,
  author={Wang, Wenhui and Zhwng, PEngland and Wei, Guichen and Ge, Zhenwei and Qin, Zhongyuan and Sun, Xin},
  booktitle={2023 4th International Symposium on Computer Engineering and Intelligent Communications (ISCEIC)}, 
  title={Buffer Overflow Vulnerability Detection Based on Static Analysis-assisted Symbolic Execution}, 
  year={2023},
  volume={},
  number={},
  pages={546-550},
  keywords={Codes;Static analysis;Buffer overflows;Resource management;static analysis;symbolic execution;buffer overflow vulnerability;vulnerability detection},
  doi={10.1109/ISCEIC59030.2023.10271194}}


@InProceedings{SE_Path_explosion,
author="Anand, Saswat
and Godefroid, Patrice
and Tillmann, Nikolai",
editor="Ramakrishnan, C. R.
and Rehof, Jakob",
title="Demand-Driven Compositional Symbolic Execution",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="367--381",
abstract="We discuss how to perform symbolic execution of large programs in a manner that is both compositional (hence more scalable) and demand-driven. Compositional symbolic execution means finding feasible interprocedural program paths by composing symbolic executions of feasible intraprocedural paths. By demand-driven, we mean that as few intraprocedural paths as possible are symbolically executed in order to form an interprocedural path leading to a specific target branch or statement of interest (like an assertion). A key originality of this work is that our demand-driven compositional interprocedural symbolic execution is performed entirely using first-order logic formulas solved with an off-the-shelf SMT (Satisfiability-Modulo-Theories) solver -- no procedure in-lining or custom algorithm is required for the interprocedural part. This allows a uniform and elegant way of summarizing procedures at various levels of detail and of composing those using logic formulas.",
isbn="978-3-540-78800-3"
}
